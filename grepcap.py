#!/usr/bin/env python2

import os
import sys
import glob
import re
from videogrep import *

debug=True


def debug(string):
    if debug:
        print("[.] {}".format(string))


def log(string):
    print "[+] {}".format(string)


def error(string):
    print "[!] {}".format(string)


def change_extension(inputfile, new_ext='srt'):
    dirname, basename = os.path.split(inputfile)
    label, ext = os.path.splitext(basename)
    new_base = '.'.join([label, new_ext])

    return os.path.join(dirname, new_base)


def videos_from_path(inputpath):
    """Take directory or file path and return list of valid video files"""
    """TODO: Directory recursion! (?)"""
    inputpath = os.path.expanduser(inputpath)
    isdir = os.path.isdir(inputpath)
    video_files = []
    debug("VIDEOS_FROM_PATH parsed out: {}, (is directory? {})".format(inputpath, isdir))
    if isdir:
        """Check for valid formats within directory"""
        """TODO: Be case-insensitive!"""
        for ext in usable_extensions:
            vids = glob.glob(os.path.join(inputpath, '*.{}'.format(ext)))
            if len(vids) > 0:
                debug("Found {} vids: {}".format(len(vids), [os.path.basename(vid) for vid in vids]))
            video_files.extend(vids)

    else:
        """Check that file requested is a usable format"""
        ext = os.path.splitext(inputpath)[-1][1:].lower()
        debug("CHECKING VIDEO FILE WITH EXTENSION: {}".format(ext))
        if ext in usable_extensions:
            debug("THAT EXTENSION IS GOOD")
            video_files.append(inputpath)
            debug("VIDEO_FILES is now: {}".format(video_files))

    return video_files


def srts_from_path(inputpath):
    """Find SRTs for a video or for a directory"""
    return list([change_extension(vid, 'srt') for vid in videos_from_path(inputpath) if os.path.isfile(vid)])


### THIS OVERRIDES THE BUILT-IN FROM VIDEOGREP ###
def get_subtitle_files(inputpaths):
    """Return a list of subtitle files."""
    srts = []
    for p in inputpaths:
        debug("GET_SUBTITLE_FILES working on: {}".format(p))
        srts.extend(srts_from_path(p))

    if len(srts) == 0:
        print "[!] No subtitle files were found."
        return False

    return srts


def main():
    import argparse

    parser = argparse.ArgumentParser(description='Generate a "supercut" of one or more video files by searching through subtitle tracks.')
    parser.add_argument('--input', '-i', dest='inputfile', nargs='*', required=True, help='video or subtitle file, or folder')
    parser.add_argument('--search', '-s', dest='search', help='search term')
    parser.add_argument('--search-type', '-st', dest='searchtype', default='re', choices=['re', 'pos', 'hyper', 'fragment', 'franken', 'word'], help='type of search')
    parser.add_argument('--use-transcript', '-t', action='store_true', dest='use_transcript', help='Use a transcript generated by pocketsphinx instead of srt files')
    parser.add_argument('--max-clips', '-m', dest='maxclips', type=int, default=0, help='maximum number of clips to use for the supercut')
    parser.add_argument('--output', '-o', dest='outputfile', default='supercut.mp4', help='name of output file')
    parser.add_argument('--demo', '-d', action='store_true', help='show results without making the supercut')
    parser.add_argument('--randomize', '-r', action='store_true', help='randomize the clips')
    parser.add_argument('--youtube', '-yt', help='grab clips from youtube based on your search')
    parser.add_argument('--padding', '-p', dest='padding', default=0, type=int, help='padding in milliseconds to add to the start and end of each clip')
    parser.add_argument('--resyncsubs', '-rs', dest='sync', default=0, type=int, help='Subtitle re-synch delay +/- in milliseconds')
    parser.add_argument('--transcribe', '-tr', dest='transcribe', action='store_true', help='Transcribe the video using audiogrep. Requires pocketsphinx')

    args = parser.parse_args()

    if not args.transcribe:
        if args.search is None:
             parser.error('argument --search/-s is required')

    if args.transcribe:
        create_timestamps(args.inputfile)
    else:
        debug("MAIN() working with: {}".format(args.inputfile))
        print(get_subtitle_files(args.inputfile))
        # videogrep(args.inputfile, args.outputfile, args.search, args.searchtype, args.maxclips, args.padding, args.demo, args.randomize, args.sync, args.use_transcript)



if __name__ == '__main__':
    main()
